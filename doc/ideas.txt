SiteHelper\
    bootstrap.php
    lib\ (third party PHP libraries)
    clases\ (core classes) mrbavii\sitehelper
    system\ (Stuff classes) mrbavii\sitestuff
        One main public class, all others used internally:
        Stuff

        Stuff::config(...) Configuration settings
        Stuff::execute();

    Entry point would be used:

    entry.php
        require bootstrap (sets up both classloaders)
        use mrbavii\sitestuff\Stuff

        Stuff::config("database stuff, etc")
        Stuff::execute()


    Usage:
        entry.php/admin (show an admin page)
        entry.php/styles/core.css (feed through cached core files)
        entry.php/scripts/core.js (feeds through cached script files, and call sitestuff.setup('path/to/entry.php');
        
    core.js
        jquery.js
        sitestuff.js

    
    sitestuff (load modules to use from external pages)

    sitestuff.module('comments');

    sitstuff.comments.load('div_id', 'comments_dbid')



SiteHelper (SiteHelper PHP Scripts)
===================================

This code provides some PHP objects that can be used in a web application. It
also provides a simple web application, which is the entire point of the code.
This application is entirely AJAX based, the PHP backend only handles the
requests and sends back a response. The PHP portion also provides access to
public portion.

Layout
------
bootstrap.php
actions/ (Where the actions for the simple web app are at)
classes/ (SiteHelper classes)
doc/
lib/
public/
tests/


sitehelper.extend('methodname', function(...) {
    ....
});




Actions
-------
/styles (concatonate and send through all the styles, create a cache file in the data directory)
/scripts (concatonate and send through all the scripts, create a cache file in the data directory)
    This will also set up a special script which will set a variable that indicates the entry point.
    The cache file will calcluated with the MD5 sum of the entry point, to ensur a changed entry
    point will result in a new file.

These can be prefixed with the "module" that needs to be loaded, so that it will only load the scripts
required for that:


Example external usage:

<html>
<head>
    <link type="text/css" rel="stylesheet" href="/path/to/entry.php/public/core.css" />
    <script type="text/javascript" language=JavaScript" src="/path/to/entry.php/public/core.js" />
</head>
<body>
    ...
    sitehelper.loadComments('divid', 'commentid');
    sitehelper.getEntryPoint(); // This would return /path/to/entry.php
    sitehelper.getEntryPoint('something/else/to/do'); // This would return /path/to/entry.php/something/else/to/do
</body>
</html>

(The public.php script will tream a requst for "core.css" and "core.js" specially,  It will
automatically build the desired "core" file and send it out:

core.css:
    ?
core.js:
    jquery.js
    sitehelper.js
    sitehelper.setup($_SERVER['SCRIPT_NAME']);

Direct example user:

http://www.something.com/entry.php/(something)

The actions could already call SiteHelper::getEntry() to load the correct javascript files



Application Setup
-----------------
SiteHelper::config(array(
    "sitehelper.datadir" => "/path/to/external/data/directory",
    "sitehelper.entry" => $_SERVER['SCRIPT_NAME'], // Normally automatically deduced
    "server.sendfile" = function($filename, $partial, $start, $end, $filesize){ ... };
    "database" => array(
        "connections" => array(
            "sitehelper" => array("driver" => 'sqlite3', 'filename" = '/path/to/data/file.sqlite3')
        )
    )
));


Classes
=======
sendfile examples


SendFile($filename)
{

    Already headers and $filesize


    $partial = Request::getRange($start, $end, $filesize);
    // This will determine if there is a partial download, and
    // also set $start and $end accordingly even if there is not one


    ...

    The backend:
    header('Accept-Ranges: bytes'); // If the backend supports partial contents

    if($partial)
    {
        Response::setRange($start, $end, $filesize)
        ...
    }

    This means the function called by server.sendfile will need the following:

    function($filename, $filesize, $start, $end, $partial);

    If it does not support partial downloads, it can just ignore $start,$end,$partial
}
Configuration Items:

server.mimetypes = array("ending" => "content-type", ...);
server.sendfile = function($filename) { ... };

Request::getRange($range, $filesize)
    Return TRUE if a partial request, otherwise FALSE
    If TRUE, $range is array($start, $end)

Response::setRange($start, $end, $filesize)


if(Request::getRange($range, $filesize))
{
    sendFile($filename, array($range[0], $range[1], $filesize));
}
else
{
    sendFile($filename);
}

sendFile($filename, $range=null)
{
    If we support ranges:
    if($range)
        Response::setRange($...
}


TODO:
    style changes:
        lowerCamelCase for methods and functions
        variable_names_like_this
    Table -> Split into QueryBuilder and Table (Maybe, maybe not)
    Database:
        On connecting, set isolation level to maximum (serializable)
        Foreign keys:
            on delete/update
                cascade
                set default
                set null
                restricted
                no action

Config
    Delay load configuration if possible.
    (How to deal with issue where Config::set or Config::merge is called before delay load?)
        Idea, keep map of all delay loaded configs (group::topname)
        When set is called, do delay_load on the name first
            Both set and merge can set the root name as well: set('group::', ...)
            so the delay load mechanism needs to get the values to set as well
            call delay_load from set and merge
            to avoid recursion, param parameter called 'load' to set and merge functions, by
            default it is true, but when delay_load merges the config in, it will be false
            delay_load(name, values)
                toload = array()
                (group, name) = split(name)
                if(name == '')
                {
                    foreach(keys(values) as key)
                    {
                        toload[] = (group, key)
                    }
                }
                else
                {
                    toload[] = (group, name)
                }

                foreach(toload as load)
                {
                    if(!loaded(load))
                    {
                        load config from filename(toload[0], toload[1])
                    }
                }


            filename(group, name)
                return str_replace('.', DIRECTORY_SEPARATOR, group) . DIRECTORY_SEPARATOR . name.split('.')[0];

ClassLoader
    register_map(dir, namespace, map)
Database
    Connector
    PdoConnector
    etc
    Grammar
    MysqlGrammar
    PgsqlGrammar
    SqliteGrammar
    etc
    Query
    etc
Cache
    Driver
    NullDriver
    MemcacheDriver
    RedisDriver
    ApcDriver
    FileDriver
    SqliteDriver
Session
Security
Template
Dispatcher (based on idea of a front end controller)
    register('path', array(data))
        callback can be a Closure or filename.
    dispatch($path=null)
        use Request::path_info() if $path is null
    (:all) (match all the rest of the url) (.*)
    (:alpha) ([a-zA-Z]*)
    (:num) ([0-9]*)
    (:alnum) ([a-zA-Z0-9]*)
    (:ident) ([a-zA-Z][a-zA-Z0-9_]*)
    (:file) (match rest of url if the pattern is ((piece)(\.|(piece))*)(/(piece)(\.|(piece))*)*
            piece is (a-zA-Z0-9_-)
Browser
    Request
    Response
        redirect
        error404 (Default action for Trigger::fire('404')
Util
    load_php
    load_ini
    guid
Exception
Language
Logger
Captcha
FormBuilder
ShCode (generic bbcode parser, parse into nested arrays)
Server
    Server information helper
        front, host, http, https, etc
Url
    register('name', 'value')
        if(not contains ':')
            if(begins with /) use local server/port as start
            else use local server/port and front end controller as start
            if setting is secure, use https
            (config information is server.front, servert.host, server.port.http, server.port.https)
            If not specified, try to auto detect
        else
            absolute path
    get('
Trigger
    A simple event hook
    fire('name', 'optional parameters')
        Call all hooks
    hook('name', callback)
        Get called when fired.
        

Database
========

$db = Database::connect();

$db->table('users')->join('groups', 'users.gid', '=', 'groups.id')
   ->where('users.id', '=', $uid)->get(array('users.uid' => 'uid'));


First, rename Connection to Grammar, and Driver to Connection


Database::connect()
{
    just create the driver, not the grammer

    internally, a grammar() method will create the grammar on demand when needed, using
    Database::drivers, passing $this (the driver)

    Table is Query builder, can use driver and grammar


    Driver has insert method, returns last inserted row id.
    For all supported database, the row id should be a row with a serially increasing number
}

class Connection
{
    __construct(...)
    {
        $this->settings = $settings);
    }

    abstract public function connect()
    {
    }

    public function grammar()
    {
        if($this->grammar === null)
        {
            $driver = $this->settings['driver'];

            use Database::drivers[$driver] to create grammar, passing $this
        }
    }

    atomic($callback)
    {
    }

    exec(...)
    query(...)
    lastid()
    table(...)
    {
        return new Table($this, $this->grammar, $tablename);
    }

    


Table methods:
    exists
    Table('users')->exists()
    Table('users')->columns()


}

Browser/Request/Response
========================

class Browser
{
    // static class
    static $filetypes = array(); // ending -> filetype
}

class Request extends Browser
{
}

class Response extends Browser
{
}



License
=======

License under MIT.  1st, we are making this based on some code from the Laravel framework.
We are actually making it our own, but using Laravel as an example for some ideas and whatnots.
To avoid issues, and since Laravel is MIT licensed, we will also use the MIT license.

