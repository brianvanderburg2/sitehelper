SiteHelper\
    bootstrap.php
    lib\ (third party PHP libraries)
    clases\ (core classes) mrbavii\sitehelper
    stuff\ (Stuff classes) mrbavii\sitestuff
        One main public class, all others used internally:
        Stuff

        Stuff::config(...) Configuration settings
        Stuff::execute();

    Entry point would be used:

    entry.php
        require bootstrap (sets up both classloaders)
        use mrbavii\sitestuff\Stuff

        Stuff::config("database stuff, etc")
        Stuff::execute()

    SiteStuff only provides an API, it does not generate any HTML or send
    any javascript or css.  Results are returned with JSON.

Permissions Helpers (Also need basic user and group helpers)
============================================================


    abstract class Permissions
    {
        protected static abstract function mergeSiblings($brother, $sister);
        protected static abstract function mergeParent($parent, $child);

        protected static function preGet($user, $object) { return FALSE; }
        protected static function postGet($user, $object, $perms) { return TRUE; }
        public abstract function get($user, $object);
    }

    class ForumPermissions extends Permissions
    {
        static $permtable = 'forum_permissions';
        static $permtable_oid = 'forum';
        static $permtable_gid = 'group';
        static $objtable = 'forums';
        static $objtable_oid = 'id';
        static $objtable_parent = 'parent';
        static $objtable_inherit = 'inherit'
        static $columns = array('canread', 'canreply', 'cancreate', 'canattach', 'attachsize');

        protected static function mergeSiblings($brother, $sister)
        {
            $results = array();
            foreach(static::$columns as $col)
            {
                if($col == 'attachsize')
                {
                    $results[$col] = max($brother[$col], $sister[$col]);
                }
                else
                {
                    if($bother[$col] == d || $sister[$col] == deny)
                    {
                        $results[$col] = deny;
                    }
                    else if(brother[$col] == allow || $siter[$col] == allow)
                    {
                        $results[$col] = allow;
                    }
                    else
                    {
                        $results[$col] = default;
                    }
                }
            }

            return $results;
        }

        protected static function mergeParent($parent, $child)
        {
            $results = array();
            foreach(static::$columns as $col)
            {
                if($col == 'attachsize')
                {
                    $result[$col] = $child[$col];
                }
                else
                {
                    if($child[col] == deny || $child[$col] == allow)
                    {
                        $result[$col] = $child[$col];
                    }
                    else
                    {
                        $result[$col] = $parent[$col];
                    }
                }
            }

            return $results;
        }
    }




SiteHelper (SiteHelper PHP Scripts)
===================================

This code provides some PHP objects that can be used in a web application. It
also provides a simple web application, which is the entire point of the code.
This application is entirely AJAX based, the PHP backend only handles the
requests and sends back a response. The PHP portion also provides access to
public portion.

Layout
------
bootstrap.php
actions/ (Where the actions for the simple web app are at)
classes/ (SiteHelper classes)
doc/
lib/
public/
tests/


Application Setup
-----------------
SiteStuff::config(array(
    "sitehelper.datadir" => "/path/to/external/data/directory",
    "sitehelper.entry" => $_SERVER['SCRIPT_NAME'], // Normally automatically deduced
    "server.sendfile" = function($filename, $partial, $start, $end, $filesize){ ... };
    "database" => array(
        "connections" => array(
            "sitehelper" => array("driver" => 'sqlite3', 'filename" = '/path/to/data/file.sqlite3')
        )
    )
));

SiteStuff::execute();

Classes
=======
sendfile examples


SendFile($filename)
{

    Already headers and $filesize


    $partial = Request::getRange($start, $end, $filesize);
    // This will determine if there is a partial download, and
    // also set $start and $end accordingly even if there is not one


    ...

    The backend:
    header('Accept-Ranges: bytes'); // If the backend supports partial contents

    if($partial)
    {
        Response::setRange($start, $end, $filesize)
        ...
    }

    This means the function called by server.sendfile will need the following:

    function($filename, $filesize, $start, $end, $partial);

    If it does not support partial downloads, it can just ignore $start,$end,$partial
}
Configuration Items:

server.mimetypes = array("ending" => "content-type", ...);
server.sendfile = function($filename) { ... };

Request::getRange($range, $filesize)
    Return TRUE if a partial request, otherwise FALSE
    If TRUE, $range is array($start, $end)

Response::setRange($start, $end, $filesize)


if(Request::getRange($range, $filesize))
{
    sendFile($filename, array($range[0], $range[1], $filesize));
}
else
{
    sendFile($filename);
}

sendFile($filename, $range=null)
{
    If we support ranges:
    if($range)
        Response::setRange($...
}


TODO:
    style changes:
        lowerCamelCase for methods and functions
        variable_names_like_this
    Table -> Split into QueryBuilder and Table (Maybe, maybe not)
    Table -> Split into Table and Builder (builder does the create stuff)
    Database:
        On connecting, set isolation level to maximum (serializable) and enable foreign keys
        Foreign keys:
            on delete/update
                cascade
                set default
                set null
                restricted
                no action

ClassLoader
    register_map(dir, namespace, map)
Database
    SQLite2 and SQLite3
    MySQL
    PostgreSQL
    maybe others
Cache
    Driver
    NullDriver (cache always returns empty)
    Memory (use internal array, only kept for the current request)
    MemcacheDriver
    RedisDriver
    ApcDriver
    FileDriver (store cache in a file)
    SqliteDriver (store cache in a file, but uses a database for all items)
    DatabaseDriver (stores cache in a named database)
Session
    Php (PHP based sessions, pretty much unlimited data size)
    Sqlite (Store session data in a database, there is a limit on data size depending on approache)
        Single row per session: id, timestamp, etc, serialized data
        Multiple rows per session, two tables
            Session (id, timestampe, information)
            Values (id, session, name, serialized value)
Security
Action
Browser
    Request
    Response
Util
    load_php
    load_ini
    guid
Exception
Logger
Captcha
    Basic
    PickByShape
    PickByColor
ShCode (generic bbcode parser, parse into nested arrays)
Server
    Server information helper
        front, host, http, https, etc
    sendfile

Database
========

$db = Database::connect();

$db->table('users')->join('groups', 'users.gid', '=', 'groups.id')
   ->where('users.id', '=', $uid)->get(array('users.uid' => 'uid'));


First, rename Connection to Grammar, and Driver to Connection


Database::connect()
{
    just create the driver, not the grammer

    internally, a grammar() method will create the grammar on demand when needed, using
    Database::drivers, passing $this (the driver)

    Table is Query builder, can use driver and grammar


    Driver has insert method, returns last inserted row id.
    For all supported database, the row id should be a row with a serially increasing number
}

class Connection
{
    __construct(...)
    {
        $this->settings = $settings);
    }

    abstract public function connect()
    {
    }

    public function grammar()
    {
        if($this->grammar === null)
        {
            $driver = $this->settings['driver'];

            use Database::drivers[$driver] to create grammar, passing $this
        }
    }

    atomic($callback)
    {
    }

    exec(...)
    query(...)
    lastid()
    table(...)
    {
        return new Table($this, $this->grammar, $tablename);
    }

    


Table methods:
    exists
    Table('users')->exists()
    Table('users')->columns()


}

Browser/Request/Response
========================

class Browser
{
    // static class
    static $filetypes = array(); // ending -> filetype
}

class Request extends Browser
{
}

class Response extends Browser
{
}



License
=======

License under MIT.  1st, we are making this based on some code from the Laravel framework.
We are actually making it our own, but using Laravel as an example for some ideas and whatnots.
But to avoid issues, and since Laravel is MIT licensed, we will also use the MIT license.

